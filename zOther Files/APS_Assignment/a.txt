### **Answer to Question 5: Algorithms, Pseudocode, and Time Complexity**  

Below are the **greedy algorithms** discussed in class, along with their **pseudocode** and **time complexity analysis**:

---

## **1. Knapsack Problem (Fractional Knapsack - Greedy Approach)**
**Approach:**  
- Sort items by **value/weight ratio**.  
- Pick the highest ratio items until the bag is full.  

**Pseudocode:**
```python
sort(items, by value/weight ratio in descending order)
remaining_capacity = max_weight
total_value = 0
for item in items:
    if item.weight <= remaining_capacity:
        total_value += item.value
        remaining_capacity -= item.weight
    else:
        fraction = remaining_capacity / item.weight
        total_value += item.value * fraction
        break
return total_value
```
**Time Complexity:**  
- Sorting: **O(n log n)**
- Iteration: **O(n)**
- **Total: O(n log n)**  

---

## **2. Job Sequencing with Deadlines**
**Approach:**  
- Sort jobs **by profit in descending order**.  
- Schedule each job in the **latest available slot** before its deadline.  

**Pseudocode:**
```python
sort(jobs, by profit in descending order)
for job in jobs:
    for slot = job.deadline downto 1:
        if slot is free:
            assign job to slot
            break
return scheduled_jobs, total_profit
```
**Time Complexity:**  
- Sorting: **O(n log n)**
- Iteration: **O(n Ã— max_deadline)**
- **Total: O(n log n) (if deadline is small)**  

---

## **3. Huffman Coding (Optimal Prefix Code)**
**Approach:**  
- Use a **min-heap** to build a Huffman tree.  
- Merge the **two smallest frequency nodes** at each step.  

**Pseudocode:**
```python
create min_heap from character frequencies
while heap has more than one node:
    left = extract_min(heap)
    right = extract_min(heap)
    new_node = merge(left, right) with sum of frequencies
    insert new_node into heap
return heap_root (Huffman Tree)
```
**Time Complexity:**  
- Building heap: **O(n)**
- Extracting and merging: **O(n log n)**
- **Total: O(n log n)**  

---

## **4. Primâ€™s Algorithm (Minimum Spanning Tree)**
**Approach:**  
- Start with **any node**.  
- Add the **smallest edge** that connects a new node.  
- Repeat until all nodes are included.  

**Pseudocode:**
```python
start from any node
mark it as visited
while not all nodes are included:
    select the smallest edge connecting a visited and unvisited node
    mark the new node as visited
    add edge to MST
return MST
```
**Time Complexity:**  
- Using **priority queue (Min-Heap): O(E log V)**  

---

## **5. Kruskalâ€™s Algorithm (Minimum Spanning Tree)**
**Approach:**  
- Sort edges **by weight**.  
- Pick the **smallest edge** that doesnâ€™t form a cycle (use Disjoint Set).  

**Pseudocode:**
```python
sort(edges, by weight)
for edge in sorted edges:
    if adding edge doesnâ€™t form a cycle:
        add edge to MST
return MST
```
**Time Complexity:**  
- Sorting edges: **O(E log E)**
- Union-Find operations: **O(E log V)**
- **Total: O(E log E) â‰ˆ O(E log V)**  

---

## **6. Dijkstraâ€™s Algorithm (Shortest Path)**
**Approach:**  
- Use a **priority queue** to explore the shortest distance to all nodes.  

**Pseudocode:**
```python
initialize distance[source] = 0, others = âˆž
priority_queue.add(source, distance=0)
while priority queue is not empty:
    u = extract_min(priority_queue)
    for each neighbor v of u:
        if distance[u] + weight(u, v) < distance[v]:
            update distance[v]
            add/update v in priority queue
return distance array
```
**Time Complexity:**  
- Using **priority queue (Min-Heap): O(E log V)**  

---

### **Summary of Time Complexities**
| Algorithm | Time Complexity |
|-----------|----------------|
| **Fractional Knapsack** | **O(n log n)** |
| **Job Sequencing** | **O(n log n)** |
| **Huffman Coding** | **O(n log n)** |
| **Primâ€™s Algorithm** | **O(E log V)** |
| **Kruskalâ€™s Algorithm** | **O(E log V)** |
| **Dijkstraâ€™s Algorithm** | **O(E log V)** |

Each of these algorithms follows the **Greedy approach**, making locally optimal choices at each step to achieve a globally optimal solution. ðŸš€